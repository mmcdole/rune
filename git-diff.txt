diff --git a/git-diff.txt b/git-diff.txt
index d105ba2..e69de29 100644
--- a/git-diff.txt
+++ b/git-diff.txt
@@ -1,888 +0,0 @@
-diff --git a/cmd/layout-test/main.go b/cmd/layout-test/main.go
-index 2e6a0ad..104180b 100644
---- a/cmd/layout-test/main.go
-+++ b/cmd/layout-test/main.go
-@@ -20,7 +20,7 @@ func main() {
- 	setupScenario(provider, *scenario)
- 
- 	inputChan := make(chan string, 256)
--	model := ui.NewModel(inputChan, provider)
-+	model := ui.NewModel(inputChan, nil, provider) // nil outbound - layout-test doesn't need it
- 	model.SetLayoutProvider(provider)
- 
- 	program := tea.NewProgram(
-@@ -166,13 +166,11 @@ func NewMockProvider() *MockProvider {
- }
- 
- // LayoutProvider implementation
--func (m *MockProvider) Layout() layout.Config          { return m.layout }
--func (m *MockProvider) Bar(name string) *layout.BarDef { return m.bars[name] }
-+func (m *MockProvider) Layout() layout.Config            { return m.layout }
-+func (m *MockProvider) Bar(name string) *layout.BarDef   { return m.bars[name] }
- func (m *MockProvider) Pane(name string) *layout.PaneDef { return m.panes[name] }
--func (m *MockProvider) PaneLines(name string) []string { return m.paneLines[name] }
--func (m *MockProvider) State() layout.ClientState      { return m.state }
--func (m *MockProvider) RenderBars(width int) map[string]layout.BarContent { return nil }
--func (m *MockProvider) HandleKeyBind(key string) bool { return false }
-+func (m *MockProvider) PaneLines(name string) []string   { return m.paneLines[name] }
-+func (m *MockProvider) State() layout.ClientState        { return m.state }
- 
- // DataProvider implementation
- func (m *MockProvider) Commands() []ui.CommandInfo { return m.commands }
-diff --git a/lua/api_bar.go b/lua/api_bar.go
-index 3f68e0b..b669eb0 100644
---- a/lua/api_bar.go
-+++ b/lua/api_bar.go
-@@ -2,8 +2,9 @@ package lua
- 
- import glua "github.com/yuin/gopher-lua"
- 
--// BarContent holds the rendered content of a bar.
--type BarContent struct {
-+// BarData represents the raw strings returned by a Lua bar renderer.
-+// Pure data with no UI dependencies - Session converts this to layout.BarContent.
-+type BarData struct {
- 	Left   string
- 	Center string
- 	Right  string
-@@ -70,6 +71,7 @@ func (e *Engine) registerBarFuncs() {
- 			e.bars.layout.Bottom = nil
- 		}
- 
-+		e.host.OnConfigChange() // Notify Session to push layout update to UI
- 		return 0
- 	}))
- }
-@@ -87,10 +89,10 @@ func tableToStrings(L *glua.LState, tbl *glua.LTable) []string {
- 
- // RenderBar calls a Lua bar render function and returns the content.
- // Called from Session on tick to update bar cache.
--func (e *Engine) RenderBar(name string, width int) (BarContent, bool) {
-+func (e *Engine) RenderBar(name string, width int) (BarData, bool) {
- 	fn, ok := e.bars.funcs[name]
- 	if !ok {
--		return BarContent{}, false
-+		return BarData{}, false
- 	}
- 
- 	// Call the Lua function with width
-@@ -98,7 +100,7 @@ func (e *Engine) RenderBar(name string, width int) (BarContent, bool) {
- 	e.L.Push(glua.LNumber(width))
- 	if err := e.L.PCall(1, 1, nil); err != nil {
- 		e.CallHook("error", "bar render: "+err.Error())
--		return BarContent{}, false
-+		return BarData{}, false
- 	}
- 
- 	result := e.L.Get(-1)
-@@ -107,15 +109,15 @@ func (e *Engine) RenderBar(name string, width int) (BarContent, bool) {
- 	// Handle return value - can be string or table {left, center, right}
- 	switch v := result.(type) {
- 	case glua.LString:
--		return BarContent{Left: string(v)}, true
-+		return BarData{Left: string(v)}, true
- 	case *glua.LTable:
--		return BarContent{
-+		return BarData{
- 			Left:   e.L.GetField(v, "left").String(),
- 			Center: e.L.GetField(v, "center").String(),
- 			Right:  e.L.GetField(v, "right").String(),
- 		}, true
- 	default:
--		return BarContent{}, false
-+		return BarData{}, false
- 	}
- }
- 
-diff --git a/lua/api_bind.go b/lua/api_bind.go
-index 9e3ae0b..4c7952a 100644
---- a/lua/api_bind.go
-+++ b/lua/api_bind.go
-@@ -16,12 +16,13 @@ func newBindRegistry() *bindRegistry {
- // registerBindFuncs registers the rune.bind API.
- func (e *Engine) registerBindFuncs() {
- 	// rune.bind(key, callback) - Register a key binding
--	// key is a string like "ctrl+r", "ctrl+t", "f1", etc.
-+	// key is a string like "ctrl+r", "ctrl+t", "f1", "j", etc.
- 	// callback receives no arguments
- 	e.L.SetField(e.runeTable, "bind", e.L.NewFunction(func(L *glua.LState) int {
- 		key := L.CheckString(1)
- 		fn := L.CheckFunction(2)
- 		e.binds.binds[key] = fn
-+		e.host.OnConfigChange() // Notify Session to push update to UI
- 		return 0
- 	}))
- 
-@@ -29,6 +30,7 @@ func (e *Engine) registerBindFuncs() {
- 	e.L.SetField(e.runeTable, "unbind", e.L.NewFunction(func(L *glua.LState) int {
- 		key := L.CheckString(1)
- 		delete(e.binds.binds, key)
-+		e.host.OnConfigChange() // Notify Session to push update to UI
- 		return 0
- 	}))
- }
-diff --git a/lua/api_state.go b/lua/api_state.go
-index 3530d51..ef7457e 100644
---- a/lua/api_state.go
-+++ b/lua/api_state.go
-@@ -8,6 +8,8 @@ type ClientState struct {
- 	Address     string
- 	ScrollMode  string // "live" or "scrolled"
- 	ScrollLines int    // Lines behind live (when scrolled)
-+	Width       int    // Terminal width
-+	Height      int    // Terminal height
- }
- 
- // registerStateFuncs creates the rune.state table.
-@@ -21,6 +23,8 @@ func (e *Engine) registerStateFuncs() {
- 	e.L.SetField(stateTable, "address", glua.LString(""))
- 	e.L.SetField(stateTable, "scroll_mode", glua.LString("live"))
- 	e.L.SetField(stateTable, "scroll_lines", glua.LNumber(0))
-+	e.L.SetField(stateTable, "width", glua.LNumber(0))
-+	e.L.SetField(stateTable, "height", glua.LNumber(0))
- }
- 
- // UpdateState pushes new client state to the Lua rune.state table.
-@@ -40,4 +44,6 @@ func (e *Engine) UpdateState(state ClientState) {
- 	e.L.SetField(t, "address", glua.LString(state.Address))
- 	e.L.SetField(t, "scroll_mode", glua.LString(state.ScrollMode))
- 	e.L.SetField(t, "scroll_lines", glua.LNumber(state.ScrollLines))
-+	e.L.SetField(t, "width", glua.LNumber(state.Width))
-+	e.L.SetField(t, "height", glua.LNumber(state.Height))
- }
-diff --git a/lua/core/50_events.lua b/lua/core/50_events.lua
-index 8a578a7..a94371c 100644
---- a/lua/core/50_events.lua
-+++ b/lua/core/50_events.lua
-@@ -1,34 +1,27 @@
- -- Default System Event Handlers
- -- Users can register additional handlers or override with lower priority
- 
---- Track current connection for status bar
--local _current_server = nil
-+-- Note: Status bar is now handled reactively by 70_status_bar.lua
-+-- It reads rune.state directly, so we don't need to call rune.status.set() here.
- 
- rune.hooks.register("ready", function()
--    rune.status.set("\027[90m● Disconnected\027[0m")
-+    -- Status bar renders from rune.state automatically
- end, { priority = 100 })
- 
- rune.hooks.register("connecting", function(addr)
-     rune.print("[System] Connecting to " .. addr .. "...")
--    rune.status.set("\027[33m● Connecting to " .. addr .. "...\027[0m")
- end, { priority = 100 })
- 
- rune.hooks.register("connected", function(addr)
--    _current_server = addr
-     rune.print("[System] Connected to " .. addr)
--    -- Green dot, subdued gray text for address
--    rune.status.set("\027[32m●\027[0m \027[90m" .. addr .. "\027[0m")
- end, { priority = 100 })
- 
- rune.hooks.register("disconnecting", function()
-     rune.print("[System] Disconnecting...")
--    rune.status.set("\027[33m● Disconnecting...\027[0m")
- end, { priority = 100 })
- 
- rune.hooks.register("disconnected", function()
--    _current_server = nil
-     rune.print("[System] Disconnected")
--    rune.status.set("\027[90m● Disconnected\027[0m")
- end, { priority = 100 })
- 
- rune.hooks.register("reloading", function()
-diff --git a/lua/host.go b/lua/host.go
-index f0cb5f0..0a05f6c 100644
---- a/lua/host.go
-+++ b/lua/host.go
-@@ -30,4 +30,9 @@ type Host interface {
- 
- 	// State - Get current client state for Lua
- 	GetClientState() ClientState
-+
-+	// OnConfigChange notifies the host that binds or layout have changed.
-+	// Called synchronously from Lua when rune.bind, rune.unbind, or
-+	// rune.ui.layout is called, allowing the host to push updates to the UI.
-+	OnConfigChange()
- }
-diff --git a/lua/mock_host_test.go b/lua/mock_host_test.go
-index fb81111..e7fa21c 100644
---- a/lua/mock_host_test.go
-+++ b/lua/mock_host_test.go
-@@ -88,12 +88,22 @@ func (m *MockHost) SetInfobar(text string) {
- 	m.InfobarCalls = append(m.InfobarCalls, text)
- }
- 
--func (m *MockHost) Pane(op, name, data string) {
-+func (m *MockHost) PaneOp(op, name, data string) {
- 	m.mu.Lock()
- 	defer m.mu.Unlock()
- 	m.PaneCalls = append(m.PaneCalls, struct{ Op, Name, Data string }{op, name, data})
- }
- 
-+func (m *MockHost) GetClientState() ClientState {
-+	return ClientState{
-+		ScrollMode: "live",
-+	}
-+}
-+
-+func (m *MockHost) OnConfigChange() {
-+	// No-op for tests - config change notifications not tracked
-+}
-+
- func (m *MockHost) TimerAfter(d time.Duration) int {
- 	m.mu.Lock()
- 	defer m.mu.Unlock()
-diff --git a/session/session.go b/session/session.go
-index 45899c1..21f1f57 100644
---- a/session/session.go
-+++ b/session/session.go
-@@ -41,12 +41,14 @@ type Session struct {
- 	// Components
- 	net    mud.Network
- 	ui     mud.UI
-+	pushUI ui.PushUI // Optional push-capable UI (nil for ConsoleUI)
- 	engine *lua.Engine
- 	timer  *timer.Service
- 
- 	// Channels
- 	events      chan mud.Event
- 	timerEvents chan timer.Event
-+	barTicker   *time.Ticker // Periodic bar re-render ticker
- 
- 	// Track last prompt overlay to commit to history when replaced
- 	lastPrompt string
-@@ -66,12 +68,12 @@ type Session struct {
- }
- 
- // New creates a new Session. It is passive - no goroutines start here.
--func New(net mud.Network, ui mud.UI, cfg Config) *Session {
-+func New(net mud.Network, uiInstance mud.UI, cfg Config) *Session {
- 	timerEvents := make(chan timer.Event, 256)
- 
- 	s := &Session{
- 		net:         net,
--		ui:          ui,
-+		ui:          uiInstance,
- 		timer:       timer.NewService(timerEvents),
- 		timerEvents: timerEvents,
- 		events:      make(chan mud.Event, 256),
-@@ -79,6 +81,11 @@ func New(net mud.Network, ui mud.UI, cfg Config) *Session {
- 		done:        make(chan struct{}),
- 	}
- 
-+	// Check if UI supports push-based updates
-+	if p, ok := uiInstance.(ui.PushUI); ok {
-+		s.pushUI = p
-+	}
-+
- 	s.engine = lua.NewEngine(s)
- 
- 	// Initialize client state defaults
-@@ -129,6 +136,12 @@ func (s *Session) Run() error {
- 		s.ui.Render(fmt.Sprintf("\033[31m[System] Boot Error: %v\033[0m", err))
- 	}
- 
-+	// Start bar re-render ticker if UI supports push updates
-+	// 250ms provides responsive updates while limiting CPU usage
-+	if s.pushUI != nil {
-+		s.barTicker = time.NewTicker(250 * time.Millisecond)
-+	}
-+
- 	// Start event loop
- 	go s.processEvents()
- 
-@@ -141,6 +154,16 @@ func (s *Session) Run() error {
- 
- // processEvents is the main event loop.
- func (s *Session) processEvents() {
-+	// Get channels for push-capable UI (may be nil)
-+	var barTickerC <-chan time.Time
-+	var outboundC <-chan any
-+	if s.pushUI != nil {
-+		if s.barTicker != nil {
-+			barTickerC = s.barTicker.C
-+		}
-+		outboundC = s.pushUI.Outbound()
-+	}
-+
- 	for {
- 		select {
- 		case <-s.done:
-@@ -157,6 +180,10 @@ func (s *Session) processEvents() {
- 		case evt := <-s.timerEvents:
- 			s.eventsProcessed.Add(1)
- 			s.engine.OnTimer(evt.ID, evt.Repeating)
-+		case <-barTickerC:
-+			s.pushBarUpdates()
-+		case msg := <-outboundC:
-+			s.handleUIMessage(msg)
- 		}
- 	}
- }
-@@ -256,6 +283,10 @@ func (s *Session) boot() error {
- 	}
- 
- 	s.engine.CallHook("ready")
-+
-+	// Push initial binds and layout to UI after all scripts loaded
-+	s.pushBindsAndLayout()
-+
- 	return nil
- }
- 
-@@ -284,6 +315,12 @@ func (s *Session) Print(text string) {
- }
- func (s *Session) Send(data string) { s.net.Send(data) }
- 
-+// OnConfigChange is called by Engine when binds or layout change.
-+// Called synchronously from Lua, so we can safely push updates.
-+func (s *Session) OnConfigChange() {
-+	s.pushBindsAndLayout()
-+}
-+
- func (s *Session) Quit() { s.shutdown() }
- 
- func (s *Session) Connect(addr string) {
-@@ -362,6 +399,10 @@ func (s *Session) loadScript(path string) {
- func (s *Session) shutdown() {
- 	s.closeOnce.Do(func() {
- 		close(s.done)
-+		// Stop bar ticker if running
-+		if s.barTicker != nil {
-+			s.barTicker.Stop()
-+		}
- 		// Stop timers and network; request UI exit.
- 		s.timer.CancelAll()
- 		s.net.Disconnect()
-@@ -471,8 +512,10 @@ func (s *Session) State() layout.ClientState {
- 	}
- }
- 
--// RenderBars calls all Lua bar renderers and returns their content.
--func (s *Session) RenderBars(width int) map[string]layout.BarContent {
-+// renderBars calls all Lua bar renderers and returns their content.
-+// Must be called from Session goroutine (thread-safe Lua access).
-+// Converts lua.BarData to layout.BarContent (decoupling lua from ui).
-+func (s *Session) renderBars(width int) map[string]layout.BarContent {
- 	names := s.engine.GetBarNames()
- 	if len(names) == 0 {
- 		return nil
-@@ -480,18 +523,82 @@ func (s *Session) RenderBars(width int) map[string]layout.BarContent {
- 
- 	result := make(map[string]layout.BarContent, len(names))
- 	for _, name := range names {
--		if content, ok := s.engine.RenderBar(name, width); ok {
-+		if data, ok := s.engine.RenderBar(name, width); ok {
- 			result[name] = layout.BarContent{
--				Left:   content.Left,
--				Center: content.Center,
--				Right:  content.Right,
-+				Left:   data.Left,
-+				Center: data.Center,
-+				Right:  data.Right,
- 			}
- 		}
- 	}
- 	return result
- }
- 
--// HandleKeyBind checks if a key has a Lua binding and executes it.
--func (s *Session) HandleKeyBind(key string) bool {
--	return s.engine.HandleKeyBind(key)
-+// handleKeyBind executes a Lua key binding.
-+// Must be called from Session goroutine (thread-safe Lua access).
-+func (s *Session) handleKeyBind(key string) {
-+	s.engine.HandleKeyBind(key)
-+}
-+
-+// pushBarUpdates renders all Lua bars and pushes to UI.
-+// Called periodically by the bar ticker.
-+func (s *Session) pushBarUpdates() {
-+	if s.pushUI == nil {
-+		return
-+	}
-+
-+	// Get current width from client state
-+	width := s.clientState.Width
-+	if width <= 0 {
-+		width = 80 // Default width until first resize
-+	}
-+
-+	// Render bars and push to UI
-+	content := s.renderBars(width)
-+	if content != nil {
-+		s.pushUI.UpdateBars(content)
-+	}
-+}
-+
-+// pushBindsAndLayout pushes current bindings and layout config to UI.
-+// Called after scripts load or reload.
-+func (s *Session) pushBindsAndLayout() {
-+	if s.pushUI == nil {
-+		return
-+	}
-+
-+	// Push bound keys
-+	keys := s.engine.GetBoundKeys()
-+	bindsMap := make(map[string]bool, len(keys))
-+	for _, key := range keys {
-+		bindsMap[key] = true
-+	}
-+	s.pushUI.UpdateBinds(bindsMap)
-+
-+	// Push layout configuration
-+	luaLayout := s.engine.GetLayout()
-+	if len(luaLayout.Top) > 0 || len(luaLayout.Bottom) > 0 {
-+		s.pushUI.UpdateLayout(luaLayout.Top, luaLayout.Bottom)
-+	}
-+}
-+
-+// handleUIMessage processes messages from the UI.
-+// Called when UI sends ExecuteBindMsg, WindowSizeChangedMsg, etc.
-+func (s *Session) handleUIMessage(msg any) {
-+	switch m := msg.(type) {
-+	case ui.ExecuteBindMsg:
-+		s.handleKeyBind(string(m))
-+	case ui.WindowSizeChangedMsg:
-+		s.clientState.Width = m.Width
-+		s.clientState.Height = m.Height
-+		s.engine.UpdateState(s.clientState)
-+		// Immediately re-render bars with new width
-+		s.pushBarUpdates()
-+	case ui.ScrollStateChangedMsg:
-+		s.clientState.ScrollMode = m.Mode
-+		s.clientState.ScrollLines = m.NewLines
-+		s.engine.UpdateState(s.clientState)
-+		// Immediately re-render bars to show scroll state
-+		s.pushBarUpdates()
-+	}
- }
-diff --git a/ui/layout/layout.go b/ui/layout/layout.go
-index 17138e4..a1e6a4a 100644
---- a/ui/layout/layout.go
-+++ b/ui/layout/layout.go
-@@ -67,6 +67,8 @@ type ClientState struct {
- }
- 
- // Provider is the interface the UI uses to get layout information.
-+// Note: This is for Go-defined bars/panes. Lua-driven UI uses push-based
-+// messages (UpdateBarsMsg, UpdateBindsMsg, etc.) instead of this interface.
- type Provider interface {
- 	// Layout returns the current layout configuration.
- 	Layout() Config
-@@ -82,12 +84,4 @@ type Provider interface {
- 
- 	// State returns the current client state for bar rendering.
- 	State() ClientState
--
--	// RenderBars calls all Lua bar renderers and returns their content.
--	// Called on tick from Update(), results are cached for View().
--	RenderBars(width int) map[string]BarContent
--
--	// HandleKeyBind checks if a key has a Lua binding and executes it.
--	// Returns true if the key was handled by Lua.
--	HandleKeyBind(key string) bool
- }
-diff --git a/ui/messages.go b/ui/messages.go
-index ef4fc22..7305a13 100644
---- a/ui/messages.go
-+++ b/ui/messages.go
-@@ -6,6 +6,7 @@ import (
- 	tea "github.com/charmbracelet/bubbletea"
- 
- 	"github.com/drake/rune/ui/components/status"
-+	"github.com/drake/rune/ui/layout"
- )
- 
- // ServerLineMsg represents a line from the MUD server.
-@@ -87,3 +88,53 @@ type PaneBindMsg struct {
- 	Key  string
- 	Name string
- }
-+
-+// --- Push-based UI Messages (Session -> UI) ---
-+
-+// UpdateBindsMsg pushes the current set of bound keys from Session to UI.
-+// UI uses this to check if a key should be sent to Session for execution.
-+type UpdateBindsMsg map[string]bool
-+
-+// UpdateBarsMsg pushes rendered bar content from Session to UI.
-+// Session runs Lua bar renderers and sends the result; UI just displays it.
-+type UpdateBarsMsg map[string]layout.BarContent
-+
-+// UpdateLayoutMsg pushes layout configuration from Session to UI.
-+type UpdateLayoutMsg struct {
-+	Top    []string
-+	Bottom []string
-+}
-+
-+// UpdateStateMsg pushes client state snapshot from Session to UI.
-+// Used for status bar rendering and other state-dependent UI.
-+type UpdateStateMsg struct {
-+	Connected   bool
-+	Address     string
-+	ScrollMode  string
-+	ScrollLines int
-+	Width       int
-+	Height      int
-+}
-+
-+// --- Push-based UI Messages (UI -> Session) ---
-+
-+// ExecuteBindMsg requests Session to execute a Lua key binding.
-+// Sent when UI detects a key that's in the boundKeys map.
-+type ExecuteBindMsg string
-+
-+// WindowSizeMsg notifies Session of window size changes.
-+// Session uses this to update rune.state.width/height.
-+type WindowSizeChangedMsg struct {
-+	Width  int
-+	Height int
-+}
-+
-+// ScrollStateChangedMsg notifies Session of scroll state changes.
-+// Session uses this to update rune.state.scroll_mode/scroll_lines.
-+type ScrollStateChangedMsg struct {
-+	Mode     string // "live" or "scrolled"
-+	NewLines int    // Lines behind live (when scrolled)
-+}
-+
-+// BarContent is an alias for layout.BarContent for convenience.
-+type BarContent = layout.BarContent
-diff --git a/ui/model.go b/ui/model.go
-index d4e4c99..f10a864 100644
---- a/ui/model.go
-+++ b/ui/model.go
-@@ -194,11 +194,16 @@ type Model struct {
- 	// Data provider (set by session)
- 	provider DataProvider
- 
--	// Layout provider (set by session, optional)
-+	// Layout provider (set by session, optional - used for Go-defined bars/panes)
- 	layoutProvider layout.Provider
- 
--	// Cached Lua bar content (updated on tick)
--	barCache map[string]layout.BarContent
-+	// Push-based state from Session (thread-safe local caches)
-+	boundKeys  map[string]bool       // Keys bound in Lua
-+	barContent map[string]BarContent // Rendered bar content from Lua
-+	luaLayout  struct {              // Layout configuration from Lua
-+		Top    []string
-+		Bottom []string
-+	}
- 
- 	// State
- 	lastPrompt  string // For deduplication
-@@ -206,6 +211,7 @@ type Model struct {
- 	width       int
- 	height      int
- 	inputChan   chan<- string
-+	outbound    chan<- any // Messages from UI to Session
- 	quitting    bool
- 	initialized bool
- 
-@@ -214,7 +220,7 @@ type Model struct {
- }
- 
- // NewModel creates a new TUI model.
--func NewModel(inputChan chan<- string, provider DataProvider) Model {
-+func NewModel(inputChan chan<- string, outbound chan<- any, provider DataProvider) Model {
- 	styles := style.DefaultStyles()
- 	scrollback := viewport.NewScrollbackBuffer(100000)
- 	vp := viewport.New(scrollback)
-@@ -247,6 +253,7 @@ func NewModel(inputChan chan<- string, provider DataProvider) Model {
- 		historyLimit: 10000,
- 		wordCache:    wordCache,
- 		inputChan:    inputChan,
-+		outbound:     outbound,
- 		provider:     provider,
- 	}
- }
-@@ -271,6 +278,8 @@ func (m Model) Update(msg tea.Msg) (tea.Model, tea.Cmd) {
- 		m.height = msg.Height
- 		m.updateDimensions()
- 		m.initialized = true
-+		// Notify Session of size change (for rune.state.width/height)
-+		m.sendOutbound(WindowSizeChangedMsg{Width: msg.Width, Height: msg.Height})
- 		return m, nil
- 
- 	// Tick for batching and clock updates
-@@ -280,12 +289,24 @@ func (m Model) Update(msg tea.Msg) (tea.Model, tea.Cmd) {
- 			m.appendLines(m.pendingLines)
- 			m.pendingLines = nil
- 		}
--		// Update Lua bar cache
--		if m.layoutProvider != nil {
--			m.barCache = m.layoutProvider.RenderBars(m.width)
--		}
-+		// Note: Bar content is now pushed by Session via UpdateBarsMsg
- 		return m, doTick()
- 
-+	// Push-based updates from Session (thread-safe)
-+	case UpdateBindsMsg:
-+		m.boundKeys = msg
-+		return m, nil
-+
-+	case UpdateBarsMsg:
-+		m.barContent = msg
-+		return m, nil
-+
-+	case UpdateLayoutMsg:
-+		m.luaLayout.Top = msg.Top
-+		m.luaLayout.Bottom = msg.Bottom
-+		m.updateDimensions()
-+		return m, nil
-+
- 	// Batched lines from aggregator
- 	case flushLinesMsg:
- 		cleanLines := make([]string, len(msg.Lines))
-@@ -418,14 +439,12 @@ func (m Model) handleKey(msg tea.KeyMsg) (tea.Model, tea.Cmd) {
- }
- 
- func (m Model) handleNormalKey(msg tea.KeyMsg) (tea.Model, tea.Cmd) {
--	// Check Lua key bindings first
--	// Note: This is called synchronously but Lua execution happens on Session goroutine.
--	// For now we trust the provider to handle threading correctly.
--	if m.layoutProvider != nil {
--		keyStr := keyToString(msg)
--		if keyStr != "" && m.layoutProvider.HandleKeyBind(keyStr) {
--			return m, nil
--		}
-+	// Check Lua key bindings (using local cache - thread-safe)
-+	keyStr := keyToString(msg)
-+	if keyStr != "" && m.boundKeys[keyStr] {
-+		// Key is bound in Lua - send to Session for execution
-+		m.sendOutbound(ExecuteBindMsg(keyStr))
-+		return m, nil
- 	}
- 
- 	// Check for bound pane toggle keys (only when input is empty)
-@@ -490,22 +509,22 @@ func (m Model) handleNormalKey(msg tea.KeyMsg) (tea.Model, tea.Cmd) {
- 
- 	case tea.KeyPgUp:
- 		m.viewport.PageUp()
--		m.status.SetScrollMode(m.viewport.Mode(), m.viewport.NewLineCount())
-+		m.updateScrollState()
- 		return m, nil
- 
- 	case tea.KeyPgDown:
- 		m.viewport.PageDown()
--		m.status.SetScrollMode(m.viewport.Mode(), m.viewport.NewLineCount())
-+		m.updateScrollState()
- 		return m, nil
- 
- 	case tea.KeyEnd:
- 		m.viewport.GotoBottom()
--		m.status.SetScrollMode(m.viewport.Mode(), m.viewport.NewLineCount())
-+		m.updateScrollState()
- 		return m, nil
- 
- 	case tea.KeyHome:
- 		m.viewport.GotoTop()
--		m.status.SetScrollMode(m.viewport.Mode(), m.viewport.NewLineCount())
-+		m.updateScrollState()
- 		return m, nil
- 
- 	case tea.KeyRunes:
-@@ -911,7 +930,7 @@ func (m *Model) appendLines(lines []string) {
- 		m.scrollback.Append(line)
- 	}
- 	m.viewport.OnNewLines(len(lines))
--	m.status.SetScrollMode(m.viewport.Mode(), m.viewport.NewLineCount())
-+	m.updateScrollState()
- }
- 
- // SetLayoutProvider sets the layout provider for custom layouts.
-@@ -919,6 +938,35 @@ func (m *Model) SetLayoutProvider(lp layout.Provider) {
- 	m.layoutProvider = lp
- }
- 
-+// sendOutbound sends a message to Session via the outbound channel.
-+// Non-blocking - drops message if channel is full.
-+func (m *Model) sendOutbound(msg any) {
-+	if m.outbound == nil {
-+		return
-+	}
-+	select {
-+	case m.outbound <- msg:
-+	default:
-+		// Drop rather than block UI
-+	}
-+}
-+
-+// updateScrollState updates the local status bar and notifies Session.
-+func (m *Model) updateScrollState() {
-+	mode := m.viewport.Mode()
-+	newLines := m.viewport.NewLineCount()
-+
-+	// Update local status component (fallback)
-+	m.status.SetScrollMode(mode, newLines)
-+
-+	// Notify Session to update rune.state
-+	modeStr := "live"
-+	if mode != 0 { // ModeScrolled
-+		modeStr = "scrolled"
-+	}
-+	m.sendOutbound(ScrollStateChangedMsg{Mode: modeStr, NewLines: newLines})
-+}
-+
- func (m *Model) updateDimensions() {
- 	layoutCfg := m.getLayout()
- 
-@@ -941,8 +989,17 @@ func (m *Model) updateDimensions() {
- 	m.aliasPicker.SetWidth(m.width)
- }
- 
--// getLayout returns the current layout, using default if no provider.
-+// getLayout returns the current layout configuration.
-+// Uses Lua layout if set, otherwise falls back to provider or default.
- func (m *Model) getLayout() layout.Config {
-+	// Prefer Lua-pushed layout
-+	if len(m.luaLayout.Top) > 0 || len(m.luaLayout.Bottom) > 0 {
-+		return layout.Config{
-+			Top:    m.luaLayout.Top,
-+			Bottom: m.luaLayout.Bottom,
-+		}
-+	}
-+	// Fall back to provider (for Go-defined layouts)
- 	if m.layoutProvider != nil {
- 		return m.layoutProvider.Layout()
- 	}
-@@ -1068,7 +1125,12 @@ func (m Model) View() string {
- 
- // renderComponent renders a component by name.
- func (m Model) renderComponent(name string) string {
--	// Built-in components
-+	// Check Lua-defined bars first (allows overriding built-ins like "status")
-+	if content, ok := m.barContent[name]; ok {
-+		return m.renderBarContent(content)
-+	}
-+
-+	// Built-in components (fallback if no Lua bar defined)
- 	switch name {
- 	case "input":
- 		// Overlay (if active) > separator > input > separator
-@@ -1096,11 +1158,6 @@ func (m Model) renderComponent(name string) string {
- 		return "" // Hidden when empty
- 	}
- 
--	// Lua-defined bar (from cache)
--	if content, ok := m.barCache[name]; ok {
--		return m.renderBarContent(content)
--	}
--
- 	// Go-defined custom bar (legacy)
- 	if m.layoutProvider != nil {
- 		if bar := m.layoutProvider.Bar(name); bar != nil {
-@@ -1175,6 +1232,7 @@ func (m Model) renderBarContent(content layout.BarContent) string {
- 	return left + strings.Repeat(" ", pad) + right
- }
- 
-+
- // renderPane renders a pane with optional title and borders.
- func (m Model) renderPane(name string, pane *layout.PaneDef) string {
- 	var parts []string
-@@ -1226,6 +1284,11 @@ func visibleLen(s string) int {
- // keyToString converts a Bubble Tea key message to a normalized string.
- // Returns empty string for keys we don't want to expose to Lua.
- func keyToString(msg tea.KeyMsg) string {
-+	// Handle regular character keys (e.g., "j", "G", "?")
-+	if msg.Type == tea.KeyRunes && len(msg.Runes) > 0 {
-+		return string(msg.Runes)
-+	}
-+
- 	switch msg.Type {
- 	case tea.KeyCtrlA:
- 		return "ctrl+a"
-diff --git a/ui/provider.go b/ui/provider.go
-index 6eb8fa3..69497f4 100644
---- a/ui/provider.go
-+++ b/ui/provider.go
-@@ -7,6 +7,24 @@ type DataProvider interface {
- 	Aliases() []AliasInfo
- }
- 
-+// PushUI extends mud.UI with push-based methods for Lua-driven UI.
-+// Session uses this interface to push updates to the UI without the UI
-+// needing to call back into Session (which would be thread-unsafe).
-+type PushUI interface {
-+	// UpdateBars pushes rendered bar content from Session.
-+	UpdateBars(content map[string]BarContent)
-+
-+	// UpdateBinds pushes the set of bound keys from Session.
-+	UpdateBinds(keys map[string]bool)
-+
-+	// UpdateLayout pushes layout configuration from Session.
-+	UpdateLayout(top, bottom []string)
-+
-+	// Outbound returns a channel of messages from UI to Session.
-+	// Session reads ExecuteBindMsg, WindowSizeChangedMsg, etc.
-+	Outbound() <-chan any
-+}
-+
- // CommandInfo represents a slash command for the UI.
- type CommandInfo struct {
- 	Name        string
-diff --git a/ui/tui.go b/ui/tui.go
-index 5de1208..102ed53 100644
---- a/ui/tui.go
-+++ b/ui/tui.go
-@@ -17,6 +17,10 @@ type BubbleTeaUI struct {
- 	// This decouples callers from tea.Program.Send() which can block.
- 	msgQueue chan tea.Msg
- 
-+	// Outbound messages from UI to Session (e.g., ExecuteBindMsg, WindowSizeChangedMsg)
-+	// Session reads from this channel in its event loop.
-+	outbound chan any
-+
- 	// Shutdown coordination
- 	done     chan struct{}
- 	doneOnce sync.Once
-@@ -30,6 +34,7 @@ func NewBubbleTeaUI() *BubbleTeaUI {
- 	return &BubbleTeaUI{
- 		inputChan: make(chan string, 2048),
- 		msgQueue:  make(chan tea.Msg, 4096),
-+		outbound:  make(chan any, 256),
- 		done:      make(chan struct{}),
- 	}
- }
-@@ -80,7 +85,7 @@ func (b *BubbleTeaUI) SetDataProvider(p DataProvider) {
- 
- // Run implements mud.UI - starts the TUI and blocks until exit.
- func (b *BubbleTeaUI) Run() error {
--	model := NewModel(b.inputChan, b.provider)
-+	model := NewModel(b.inputChan, b.outbound, b.provider)
- 
- 	b.program = tea.NewProgram(
- 		model,
-@@ -171,3 +176,28 @@ func (b *BubbleTeaUI) ClearPane(name string) {
- func (b *BubbleTeaUI) BindPaneKey(key, name string) {
- 	b.send(PaneBindMsg{Key: key, Name: name})
- }
-+
-+// --- Push-based messages from Session to UI ---
-+
-+// UpdateBars sends rendered bar content from Session to UI.
-+func (b *BubbleTeaUI) UpdateBars(content map[string]BarContent) {
-+	b.send(UpdateBarsMsg(content))
-+}
-+
-+// UpdateBinds sends the current set of bound keys from Session to UI.
-+func (b *BubbleTeaUI) UpdateBinds(keys map[string]bool) {
-+	b.send(UpdateBindsMsg(keys))
-+}
-+
-+// UpdateLayout sends layout configuration from Session to UI.
-+func (b *BubbleTeaUI) UpdateLayout(top, bottom []string) {
-+	b.send(UpdateLayoutMsg{Top: top, Bottom: bottom})
-+}
-+
-+// --- Outbound messages from UI to Session ---
-+
-+// Outbound returns a channel of messages from UI to Session.
-+// Session should read from this channel in its event loop.
-+func (b *BubbleTeaUI) Outbound() <-chan any {
-+	return b.outbound
-+}
diff --git a/lua/api_input.go b/lua/api_input.go
index 5db472f..2f9d972 100644
--- a/lua/api_input.go
+++ b/lua/api_input.go
@@ -7,6 +7,12 @@ func (e *Engine) registerInputFuncs() {
 	inp := e.L.NewTable()
 	e.L.SetField(e.runeTable, "input", inp)
 
+	// rune.input.get() - Get the current input line content
+	e.L.SetField(inp, "get", e.L.NewFunction(func(L *glua.LState) int {
+		L.Push(glua.LString(e.host.GetInput()))
+		return 1
+	}))
+
 	// rune.input.set(text) - Set the input line content
 	e.L.SetField(inp, "set", e.L.NewFunction(func(L *glua.LState) int {
 		text := L.CheckString(1)
diff --git a/lua/host.go b/lua/host.go
index ca239f8..28a4435 100644
--- a/lua/host.go
+++ b/lua/host.go
@@ -44,7 +44,8 @@ type Host interface {
 	GetHistory() []string
 	AddToHistory(cmd string)
 
-	// Input - Set input line content (for picker selection)
+	// Input - Get/Set input line content
+	GetInput() string
 	SetInput(text string)
 
 	// Timers - Timer service owns IDs, scheduling, and cancellation
diff --git a/lua/mock_host_test.go b/lua/mock_host_test.go
index eef9b50..ce4a8e7 100644
--- a/lua/mock_host_test.go
+++ b/lua/mock_host_test.go
@@ -5,6 +5,9 @@ import (
 	"time"
 )
 
+// Compile-time check that MockHost implements Host
+var _ Host = (*MockHost)(nil)
+
 // MockHost implements Host for testing.
 type MockHost struct {
 	mu sync.Mutex
@@ -134,6 +137,10 @@ func (m *MockHost) AddToHistory(cmd string) {
 	// No-op for tests
 }
 
+func (m *MockHost) GetInput() string {
+	return "" // Return empty for tests
+}
+
 func (m *MockHost) SetInput(text string) {
 	// No-op for tests
 }
diff --git a/session/session.go b/session/session.go
index 6c4e14f..745ec06 100644
--- a/session/session.go
+++ b/session/session.go
@@ -20,9 +20,6 @@ import (
 	"github.com/drake/rune/ui/layout"
 )
 
-// Ensure Session implements lua.Host at compile time
-var _ lua.Host = (*Session)(nil)
-
 // Ensure Session implements layout.Provider at compile time
 var _ layout.Provider = (*Session)(nil)
 
@@ -35,13 +32,20 @@ type Config struct {
 
 // Session orchestrates the MUD client components.
 type Session struct {
-	// Components
+	// Infrastructure
 	net    mud.Network
 	ui     mud.UI
 	pushUI ui.PushUI // Optional push-capable UI (nil for ConsoleUI)
-	engine *lua.Engine
 	timer  *timer.Service
 
+	// Scripting
+	engine  *lua.Engine
+	adapter *LuaAdapter
+
+	// Managers
+	history   *HistoryManager
+	callbacks *CallbackManager
+
 	// Channels
 	events      chan mud.Event
 	timerEvents chan timer.Event
@@ -63,13 +67,8 @@ type Session struct {
 	// Client state (for Lua rune.state access)
 	clientState lua.ClientState
 
-	// Input history (owned by Session, pushed to UI for Up/Down navigation)
-	history      []string
-	historyLimit int
-
-	// Picker callback registry
-	pickerCallbacks map[string]func(string)
-	nextPickerID    int
+	// Current input content (tracked for rune.input.get())
+	currentInput string
 }
 
 // New creates a new Session. It is passive - no goroutines start here.
@@ -77,16 +76,15 @@ func New(net mud.Network, uiInstance mud.UI, cfg Config) *Session {
 	timerEvents := make(chan timer.Event, 256)
 
 	s := &Session{
-		net:             net,
-		ui:              uiInstance,
-		timer:           timer.NewService(timerEvents),
-		timerEvents:     timerEvents,
-		events:          make(chan mud.Event, 256),
-		config:          cfg,
-		done:            make(chan struct{}),
-		history:         make([]string, 0, 1000),
-		historyLimit:    10000,
-		pickerCallbacks: make(map[string]func(string)),
+		net:         net,
+		ui:          uiInstance,
+		timer:       timer.NewService(timerEvents),
+		timerEvents: timerEvents,
+		events:      make(chan mud.Event, 256),
+		config:      cfg,
+		done:        make(chan struct{}),
+		history:     NewHistoryManager(10000),
+		callbacks:   NewCallbackManager(),
 	}
 
 	// Check if UI supports push-based updates
@@ -94,7 +92,11 @@ func New(net mud.Network, uiInstance mud.UI, cfg Config) *Session {
 		s.pushUI = p
 	}
 
-	s.engine = lua.NewEngine(s)
+	// Create adapter (bridges Lua services to Session infrastructure)
+	s.adapter = NewLuaAdapter(s)
+
+	// Create engine with adapter (implements all Lua service interfaces)
+	s.engine = lua.NewEngine(s.adapter)
 
 	// Initialize client state defaults
 	s.clientState.ScrollMode = "live"
@@ -225,7 +227,7 @@ func (s *Session) handleEvent(event mud.Event) {
 		}
 		// Add non-empty input to history
 		if event.Payload != "" {
-			s.AddToHistory(event.Payload)
+			s.history.Add(event.Payload)
 		}
 		s.engine.OnInput(event.Payload)
 		// Local echo to scrollback (styled in UI)
@@ -298,7 +300,6 @@ func (s *Session) boot() error {
 
 	// Push initial state to UI after all scripts loaded
 	s.pushBindsAndLayout()
-	s.pushHistory()
 
 	return nil
 }
@@ -309,35 +310,20 @@ func (s *Session) handleControl(ctrl mud.ControlOp) {
 	case mud.ActionQuit:
 		s.shutdown()
 	case mud.ActionConnect:
-		s.Connect(ctrl.Address)
+		s.connect(ctrl.Address)
 	case mud.ActionDisconnect:
-		s.Disconnect()
+		s.disconnect()
 	case mud.ActionReload:
-		s.Reload()
+		s.reload()
 	case mud.ActionLoadScript:
 		s.loadScript(ctrl.ScriptPath)
 	}
 }
 
-// --- Host Implementation ---
-
-func (s *Session) Print(text string) {
-	// Print is called synchronously from Lua (within the event loop),
-	// so render directly instead of going through the channel to avoid deadlock.
-	s.ui.RenderDisplayLine(text)
-}
-func (s *Session) Send(data string) { s.net.Send(data) }
-
-// OnConfigChange is called by Engine when binds or layout change.
-// Called synchronously from Lua, so we can safely push updates.
-func (s *Session) OnConfigChange() {
-	s.pushBindsAndLayout()
-	s.pushBarUpdates() // Render new bars immediately
-}
-
-func (s *Session) Quit() { s.shutdown() }
+// --- Internal helpers for LuaAdapter ---
 
-func (s *Session) Connect(addr string) {
+// connect handles connection logic (called by adapter and handleControl).
+func (s *Session) connect(addr string) {
 	s.engine.CallHook("connecting", addr)
 	go func() {
 		err := s.net.Connect(addr)
@@ -361,7 +347,8 @@ func (s *Session) Connect(addr string) {
 	}()
 }
 
-func (s *Session) Disconnect() {
+// disconnect handles disconnection logic (called by adapter and handleControl).
+func (s *Session) disconnect() {
 	s.engine.CallHook("disconnecting")
 	s.net.Disconnect()
 	s.clientState.Connected = false
@@ -371,14 +358,9 @@ func (s *Session) Disconnect() {
 	s.pushBarUpdates() // Immediate UI update
 }
 
-// Load loads a Lua script synchronously. Called from Lua, so executes directly.
-func (s *Session) Load(path string) {
-	s.loadScript(path)
-}
-
-// Reload schedules VM reinitialization. Must be deferred because it destroys the
-// currently executing Lua state. Uses non-blocking send to avoid deadlock.
-func (s *Session) Reload() {
+// reload schedules VM reinitialization (called by adapter and handleControl).
+// Must be deferred because it destroys the currently executing Lua state.
+func (s *Session) reload() {
 	s.engine.CallHook("reloading")
 	select {
 	case s.events <- mud.Event{
@@ -396,7 +378,7 @@ func (s *Session) Reload() {
 	}
 }
 
-// loadScript loads a Lua script file and notifies hooks. Runs on the session goroutine.
+// loadScript loads a Lua script file and notifies hooks (called by adapter).
 func (s *Session) loadScript(path string) {
 	if path == "" {
 		s.ui.Render("\033[31mLoad Failed: empty path\033[0m")
@@ -426,101 +408,6 @@ func (s *Session) shutdown() {
 	})
 }
 
-func (s *Session) SetStatus(text string)  { s.ui.SetStatus(text) }
-func (s *Session) SetInfobar(text string) { s.ui.SetInfobar(text) }
-
-func (s *Session) PaneCreate(name string)      { s.ui.CreatePane(name) }
-func (s *Session) PaneWrite(name, text string) { s.ui.WritePane(name, text) }
-func (s *Session) PaneToggle(name string)      { s.ui.TogglePane(name) }
-func (s *Session) PaneClear(name string)       { s.ui.ClearPane(name) }
-
-// ShowPicker displays a generic picker overlay.
-// Called from Lua via rune.ui.picker.show().
-// inline: if true, picker filters based on input; if false, picker captures keyboard.
-func (s *Session) ShowPicker(title string, items []lua.PickerItem, onSelect func(string), inline bool) {
-	if s.pushUI == nil {
-		return
-	}
-
-	// Generate unique callback ID
-	s.nextPickerID++
-	id := fmt.Sprintf("p%d", s.nextPickerID)
-
-	// Store callback
-	s.pickerCallbacks[id] = onSelect
-
-	// Convert lua.PickerItem to ui.GenericItem
-	uiItems := make([]ui.GenericItem, len(items))
-	for i, item := range items {
-		uiItems[i] = ui.GenericItem{
-			Text:        item.Text,
-			Description: item.Description,
-			Value:       item.Value,
-			MatchDesc:   item.MatchDesc,
-		}
-	}
-
-	// Push to UI
-	s.pushUI.ShowPicker(title, uiItems, id, inline)
-}
-
-// GetHistory returns the input history for Lua.
-func (s *Session) GetHistory() []string {
-	// Return a copy to prevent modification
-	result := make([]string, len(s.history))
-	copy(result, s.history)
-	return result
-}
-
-// AddToHistory adds a command to history.
-func (s *Session) AddToHistory(cmd string) {
-	if cmd == "" {
-		return
-	}
-	// Don't add duplicates of the last command
-	if len(s.history) > 0 && s.history[len(s.history)-1] == cmd {
-		return
-	}
-	s.history = append(s.history, cmd)
-	// Trim if over limit
-	if len(s.history) > s.historyLimit {
-		s.history = s.history[len(s.history)-s.historyLimit:]
-	}
-	s.pushHistory()
-}
-
-// SetInput sets the input line content.
-func (s *Session) SetInput(text string) {
-	if s.pushUI != nil {
-		s.pushUI.SetInput(text)
-	}
-}
-
-// TimerAfter schedules a one-shot timer. Returns the timer ID.
-func (s *Session) TimerAfter(d time.Duration) int {
-	return s.timer.After(d)
-}
-
-// TimerEvery schedules a repeating timer. Returns the timer ID.
-func (s *Session) TimerEvery(d time.Duration) int {
-	return s.timer.Every(d)
-}
-
-// TimerCancel cancels a timer by ID.
-func (s *Session) TimerCancel(id int) {
-	s.timer.Cancel(id)
-}
-
-// TimerCancelAll cancels all timers.
-func (s *Session) TimerCancelAll() {
-	s.timer.CancelAll()
-}
-
-// GetClientState returns the current client state for Lua.
-func (s *Session) GetClientState() lua.ClientState {
-	return s.clientState
-}
-
 // --- LayoutProvider Implementation ---
 
 // Layout returns the current layout configuration from Lua.
@@ -628,13 +515,6 @@ func (s *Session) pushBindsAndLayout() {
 	}
 }
 
-// pushHistory pushes input history to UI for Up/Down navigation.
-func (s *Session) pushHistory() {
-	if s.pushUI != nil {
-		s.pushUI.UpdateHistory(s.history)
-	}
-}
-
 // handleUIMessage processes messages from the UI.
 // Called when UI sends ExecuteBindMsg, WindowSizeChangedMsg, etc.
 func (s *Session) handleUIMessage(msg any) {
@@ -654,12 +534,8 @@ func (s *Session) handleUIMessage(msg any) {
 		// Immediately re-render bars to show scroll state
 		s.pushBarUpdates()
 	case ui.PickerSelectMsg:
-		// Look up and execute the callback
-		if cb, ok := s.pickerCallbacks[m.CallbackID]; ok {
-			delete(s.pickerCallbacks, m.CallbackID) // One-shot
-			if m.Accepted && cb != nil {
-				cb(m.Value)
-			}
-		}
+		s.callbacks.Execute(m.CallbackID, m.Value, m.Accepted)
+	case ui.InputChangedMsg:
+		s.currentInput = string(m)
 	}
 }
diff --git a/ui/components/picker/picker.go b/ui/components/picker/picker.go
index f7e93ba..909f6c9 100644
--- a/ui/components/picker/picker.go
+++ b/ui/components/picker/picker.go
@@ -16,15 +16,15 @@ type Config struct {
 
 // Model is a generic fuzzy-filtering selector.
 type Model[T Item] struct {
-	items      []T
-	filtered   []T
-	matches    []util.Match
-	query      string
-	selected   int
-	scrollOff  int
-	config     Config
-	styles     style.Styles
-	width      int
+	items     []T
+	filtered  []T
+	matches   []util.Match
+	query     string
+	selected  int
+	scrollOff int
+	config    Config
+	styles    style.Styles
+	width     int
 }
 
 // New creates a new picker with the given configuration.
diff --git a/ui/messages.go b/ui/messages.go
index 435c348..6b5a083 100644
--- a/ui/messages.go
+++ b/ui/messages.go
@@ -125,6 +125,10 @@ type ScrollStateChangedMsg struct {
 	NewLines int    // Lines behind live (when scrolled)
 }
 
+// InputChangedMsg notifies Session of input content changes.
+// Session tracks this so Lua can query current input via rune.input.get().
+type InputChangedMsg string
+
 // BarContent is an alias for layout.BarContent for convenience.
 type BarContent = layout.BarContent
 
@@ -145,10 +149,6 @@ type ShowPickerMsg struct {
 // Sent from Session when Lua calls rune.input.set().
 type SetInputMsg string
 
-// UpdateHistoryMsg pushes input history from Session to UI.
-// UI uses this for Up/Down arrow navigation.
-type UpdateHistoryMsg []string
-
 // --- Picker Messages (UI -> Session) ---
 
 // PickerSelectMsg is sent from UI back to Session when user interacts with picker.
diff --git a/ui/model.go b/ui/model.go
index 1b02ab1..5e55ac6 100644
--- a/ui/model.go
+++ b/ui/model.go
@@ -41,11 +41,6 @@ type Model struct {
 	pickerCB     string // Current callback ID for picker selection
 	pickerInline bool   // True if picker is in inline mode (filters based on input content)
 
-	// History state - pushed from Session
-	history      []string
-	historyIndex int    // -1 = draft, 0..n = history position
-	historyDraft string // Preserved when browsing history
-
 	// Tab completion
 	wordCache *util.CompletionEngine
 
@@ -93,9 +88,7 @@ func NewModel(inputChan chan<- string, outbound chan<- any) Model {
 			MaxVisible: 10,
 			EmptyText:  "No matches",
 		}, styles),
-		history:      make([]string, 0, 1000),
-		historyIndex: -1,
-		wordCache:    wordCache,
+		wordCache: wordCache,
 		inputChan:    inputChan,
 		outbound:     outbound,
 	}
@@ -150,11 +143,6 @@ func (m Model) Update(msg tea.Msg) (tea.Model, tea.Cmd) {
 		m.updateDimensions()
 		return m, nil
 
-	case UpdateHistoryMsg:
-		m.history = msg
-		m.historyIndex = -1 // Reset navigation
-		return m, nil
-
 	case ShowPickerMsg:
 		m.picker.SetItems(msg.Items)
 		m.pickerCB = msg.CallbackID
@@ -283,8 +271,6 @@ func (m Model) handleKey(msg tea.KeyMsg) (tea.Model, tea.Cmd) {
 			return m, nil
 		}
 		m.input.Reset()
-		m.historyIndex = -1
-		m.historyDraft = ""
 		return m, nil
 
 	case tea.KeyEsc:
@@ -295,8 +281,6 @@ func (m Model) handleKey(msg tea.KeyMsg) (tea.Model, tea.Cmd) {
 			return m, nil
 		}
 		m.input.Reset()
-		m.historyIndex = -1
-		m.historyDraft = ""
 		return m, nil
 	}
 
@@ -313,9 +297,14 @@ func (m Model) handleNormalKey(msg tea.KeyMsg) (tea.Model, tea.Cmd) {
 	// Check Lua key bindings (using local cache - thread-safe)
 	keyStr := keyToString(msg)
 	if keyStr != "" && m.boundKeys[keyStr] {
-		// Key is bound in Lua - send to Session for execution
-		m.sendOutbound(ExecuteBindMsg(keyStr))
-		return m, nil
+		// Don't intercept Up/Down when inline picker is active - let picker handle them
+		if m.pickerActive && m.pickerInline && (keyStr == "up" || keyStr == "down") {
+			// Fall through to picker handling below
+		} else {
+			// Key is bound in Lua - send to Session for execution
+			m.sendOutbound(ExecuteBindMsg(keyStr))
+			return m, nil
+		}
 	}
 
 	// Check for bound pane toggle keys (only when input is empty)
@@ -381,18 +370,6 @@ func (m Model) handleNormalKey(msg tea.KeyMsg) (tea.Model, tea.Cmd) {
 			m.scrollback.Append("\033[31m[WARNING] Input dropped - engine lagging\033[0m")
 		}
 		m.input.Reset()
-		m.historyIndex = -1
-		m.historyDraft = ""
-		return m, nil
-
-	case tea.KeyUp:
-		m.historyUp()
-		m.updateSuggestions()
-		return m, nil
-
-	case tea.KeyDown:
-		m.historyDown()
-		m.updateSuggestions()
 		return m, nil
 
 	case tea.KeyCtrlU:
@@ -427,9 +404,15 @@ func (m Model) handleNormalKey(msg tea.KeyMsg) (tea.Model, tea.Cmd) {
 	}
 
 	// Forward to input
+	oldValue := m.input.Value()
 	newInput, cmd := m.input.Update(msg)
 	m.input = *newInput
 
+	// Notify Session if input content changed (for rune.input.get())
+	if newValue := m.input.Value(); newValue != oldValue {
+		m.sendOutbound(InputChangedMsg(newValue))
+	}
+
 	// Update linked picker filter based on new input content
 	m.updateInlinePicker()
 
@@ -507,81 +490,6 @@ func (m Model) handlePickerKey(msg tea.KeyMsg) (tea.Model, tea.Cmd) {
 	return m, nil
 }
 
-// History management
-
-func (m *Model) historyUp() {
-	if len(m.history) == 0 {
-		return
-	}
-
-	if m.historyIndex == -1 {
-		// Save current input as draft before entering history
-		m.historyDraft = m.input.Value()
-	}
-
-	// If we have a prefix (draft), search for matching history
-	if m.historyDraft != "" {
-		start := m.historyIndex - 1
-		if m.historyIndex == -1 {
-			start = len(m.history) - 1
-		}
-		for i := start; i >= 0; i-- {
-			if strings.HasPrefix(m.history[i], m.historyDraft) {
-				m.historyIndex = i
-				m.input.SetValue(m.history[i])
-				m.input.CursorEnd()
-				return
-			}
-		}
-		// No match found, stay where we are
-		return
-	}
-
-	// No prefix - cycle through all history
-	if m.historyIndex == -1 {
-		m.historyIndex = len(m.history) - 1
-	} else if m.historyIndex > 0 {
-		m.historyIndex--
-	}
-
-	m.input.SetValue(m.history[m.historyIndex])
-	m.input.CursorEnd()
-}
-
-func (m *Model) historyDown() {
-	if m.historyIndex == -1 {
-		return // Already at draft
-	}
-
-	// If we have a prefix (draft), search for matching history
-	if m.historyDraft != "" {
-		for i := m.historyIndex + 1; i < len(m.history); i++ {
-			if strings.HasPrefix(m.history[i], m.historyDraft) {
-				m.historyIndex = i
-				m.input.SetValue(m.history[i])
-				m.input.CursorEnd()
-				return
-			}
-		}
-		// No more matches - return to draft
-		m.historyIndex = -1
-		m.input.SetValue(m.historyDraft)
-		m.input.CursorEnd()
-		return
-	}
-
-	// No prefix - cycle through all history
-	if m.historyIndex < len(m.history)-1 {
-		m.historyIndex++
-		m.input.SetValue(m.history[m.historyIndex])
-	} else {
-		// Return to draft
-		m.historyIndex = -1
-		m.input.SetValue(m.historyDraft)
-	}
-	m.input.CursorEnd()
-}
-
 // Completion and suggestions
 
 func (m *Model) updateSuggestions() {
@@ -922,7 +830,7 @@ func (m Model) renderBarContent(content layout.BarContent) string {
 	// Calculate spacing
 	if center != "" {
 		// Three-part layout: left ... center ... right
-		leftPad := (m.width - centerLen) / 2 - leftLen
+		leftPad := (m.width-centerLen)/2 - leftLen
 		if leftPad < 1 {
 			leftPad = 1
 		}
@@ -1074,6 +982,10 @@ func keyToString(msg tea.KeyMsg) string {
 		return "f11"
 	case tea.KeyF12:
 		return "f12"
+	case tea.KeyUp:
+		return "up"
+	case tea.KeyDown:
+		return "down"
 	default:
 		return ""
 	}
diff --git a/ui/provider.go b/ui/provider.go
index a19094b..b3b5088 100644
--- a/ui/provider.go
+++ b/ui/provider.go
@@ -13,9 +13,6 @@ type PushUI interface {
 	// UpdateLayout pushes layout configuration from Session.
 	UpdateLayout(top, bottom []string)
 
-	// UpdateHistory pushes input history from Session (for Up/Down navigation).
-	UpdateHistory(history []string)
-
 	// ShowPicker displays the picker overlay with items.
 	// inline: if true, picker filters based on input; if false, picker captures keyboard.
 	ShowPicker(title string, items []GenericItem, callbackID string, inline bool)
diff --git a/ui/tui.go b/ui/tui.go
index 0c144c0..697d74e 100644
--- a/ui/tui.go
+++ b/ui/tui.go
@@ -185,11 +185,6 @@ func (b *BubbleTeaUI) UpdateLayout(top, bottom []string) {
 	b.send(UpdateLayoutMsg{Top: top, Bottom: bottom})
 }
 
-// UpdateHistory sends input history from Session to UI.
-func (b *BubbleTeaUI) UpdateHistory(history []string) {
-	b.send(UpdateHistoryMsg(history))
-}
-
 // ShowPicker displays a picker overlay with items.
 // inline: if true, picker filters based on input; if false, picker captures keyboard.
 func (b *BubbleTeaUI) ShowPicker(title string, items []GenericItem, callbackID string, inline bool) {
diff --git a/ui/util/ansi.go b/ui/util/ansi.go
index e49074f..8a03201 100644
--- a/ui/util/ansi.go
+++ b/ui/util/ansi.go
@@ -31,9 +31,9 @@ func VisibleLen(s string) int {
 // MUD clients typically ignore these to prevent server-side screen wipes.
 func FilterClearSequences(line string) string {
 	// Filter clear screen sequences
-	line = strings.ReplaceAll(line, "\x1b[2J", "")    // Clear entire screen
-	line = strings.ReplaceAll(line, "\x1b[H", "")     // Move cursor to home
-	line = strings.ReplaceAll(line, "\x1b[0;0H", "")  // Move cursor to 0,0
-	line = strings.ReplaceAll(line, "\x1b[1;1H", "")  // Move cursor to 1,1
+	line = strings.ReplaceAll(line, "\x1b[2J", "")   // Clear entire screen
+	line = strings.ReplaceAll(line, "\x1b[H", "")    // Move cursor to home
+	line = strings.ReplaceAll(line, "\x1b[0;0H", "") // Move cursor to 0,0
+	line = strings.ReplaceAll(line, "\x1b[1;1H", "") // Move cursor to 1,1
 	return line
 }
